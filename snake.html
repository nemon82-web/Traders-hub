<!DOCTYPE html>
<html>
<head>
    <title>Ultimate Snake Game</title>
    <style>
        body {
            background: #1a1a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            font-family: 'Arial', sans-serif;
            color: #fff;
            overflow: hidden;
        }

        .game-container {
            display: flex;
            gap: 20px;
            background: #2a2a2a;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 0 30px rgba(0,0,0,0.6);
            position: relative;
        }

        canvas {
            border: 2px solid #3a3a3a;
            border-radius: 8px;
        }

        .info-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
            min-width: 180px;
        }

        .stats {
            background: linear-gradient(145deg, #333, #2a2a2a);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .powerup-list {
            background: #333;
            padding: 15px;
            border-radius: 8px;
            min-height: 100px;
        }

        .controls {
            background: #333;
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.5;
        }

        .particle {
            position: absolute;
            pointer-events: none;
            border-radius: 50%;
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            text-shadow: 0 0 10px red;
            display: none;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="game" width="500" height="500"></canvas>
        <div class="info-panel">
            <div class="stats">
                <div>Score: <span id="score">0</span></div>
                <div>Length: <span id="length">1</span></div>
                <div>High Score: <span id="highscore">0</span></div>
                <div>Time: <span id="time">0:00</span></div>
                <div>Combo: <span id="combo">x1</span></div>
            </div>
            <div class="powerup-list">
                <h4>Active Powerups:</h4>
                <div id="powerups"></div>
            </div>
            <div class="controls">
                ←↑→↓ : Move<br>
                Space: Pause<br>
                R: Rainbow Mode<br>
                M: Toggle Music<br>
                [1-3]: Use Powerup<br>
                Enter: New Game
            </div>
        </div>
        <div class="game-over" id="gameOver">GAME OVER</div>
    </div>

<script>
// Audio Setup
const audioContext = new (window.AudioContext || window.webkitAudioContext)();
const gainNode = audioContext.createGain();
gainNode.connect(audioContext.destination);
gainNode.gain.value = 0.2;

function createSound(frequency, type = 'sine', duration = 0.2) {
    const oscillator = audioContext.createOscillator();
    const envelope = audioContext.createGain();
    
    oscillator.type = type;
    oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
    
    envelope.gain.setValueAtTime(0.8, audioContext.currentTime);
    envelope.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
    
    oscillator.connect(envelope);
    envelope.connect(gainNode);
    
    oscillator.start();
    oscillator.stop(audioContext.currentTime + duration);
}

// Sound Effects
const SFX = {
    eat: () => createSound(784, 'square'),
    specialEat: () => createSound(1046.5, 'sine', 0.4),
    powerup: () => createSound(523.25, 'triangle', 0.3),
    gameOver: () => {
        createSound(220, 'sine', 0.8);
        createSound(164.81, 'sine', 0.8);
    },
    combo: (multiplier) => createSound(200 + (100 * multiplier), 'sawtooth', 0.3)
};

// Game Constants
const GRID_SIZE = 25;
const CELL_SIZE = 20;
const INITIAL_SPEED = 150;
const POWERUP_TYPES = ['speed', 'shield', 'double', 'slow'];
const POWERUP_COLORS = ['#FFD700', '#00FF00', '#FF00FF', '#00FFFF'];

// Game State
let snake = [];
let food = [];
let direction = 'right';
let nextDirection = 'right';
let score = 0;
let gameSpeed = INITIAL_SPEED;
let gameLoop;
let paused = false;
let rainbowMode = false;
let highScore = localStorage.getItem('snakeHighScore') || 0;
let startTime = Date.now();
let comboMultiplier = 1;
let comboTimeout;
let activePowerups = [];
let particles = [];

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const gameOverElement = document.getElementById('gameOver');

class Powerup {
    constructor() {
        this.type = POWERUP_TYPES[Math.floor(Math.random() * POWERUP_TYPES.length)];
        this.x = Math.floor(Math.random() * GRID_SIZE);
        this.y = Math.floor(Math.random() * GRID_SIZE);
        this.color = POWERUP_COLORS[POWERUP_TYPES.indexOf(this.type)];
        this.duration = this.type === 'slow' ? 10000 : 5000;
        this.createdAt = Date.now();
    }

    apply() {
        activePowerups.push({...this, expiresAt: Date.now() + this.duration});
        SFX.powerup();
        
        switch(this.type) {
            case 'speed':
                gameSpeed = Math.max(50, gameSpeed - 100);
                break;
            case 'shield':
                // Shield effect handled in collision detection
                break;
            case 'double':
                score += 50;
                break;
            case 'slow':
                gameSpeed += 200;
                break;
        }
        
        clearInterval(gameLoop);
        gameLoop = setInterval(gameStep, gameSpeed);
    }
}

function generateFood() {
    const types = ['normal', 'special', 'powerup'];
    const weights = [0.7, 0.2, 0.1];
    
    while(food.length < 3) {
        const type = types[weights.reduce((acc, w, i) => acc > w ? acc : i, Math.random())];
        const newFood = {
            x: Math.floor(Math.random() * GRID_SIZE),
            y: Math.floor(Math.random() * GRID_SIZE),
            type: type,
            color: type === 'special' ? '#FF4081' : 
                   type === 'powerup' ? '#FFD700' : '#F44336'
        };
        
        if (!snake.some(s => s.x === newFood.x && s.y === newFood.y) &&
            !food.some(f => f.x === newFood.x && f.y === newFood.y)) {
            food.push(newFood);
        }
    }
}

function createParticles(x, y, color) {
    for(let i = 0; i < 10; i++) {
        particles.push({
            x: x * CELL_SIZE + CELL_SIZE/2,
            y: y * CELL_SIZE + CELL_SIZE/2,
            color: color,
            radius: Math.random() * 4 + 2,
            dx: (Math.random() - 0.5) * 8,
            dy: (Math.random() - 0.5) * 8,
            life: 1
        });
    }
}

function drawParticles() {
    particles = particles.filter(p => {
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life;
        ctx.fill();
        
        p.x += p.dx;
        p.y += p.dy;
        p.dy += 0.1;
        p.life -= 0.02;
        
        return p.life > 0;
    });
    ctx.globalAlpha = 1;
}

function drawSnake() {
    snake.forEach((segment, index) => {
        const head = index === 0;
        const tail = index === snake.length - 1;
        const hue = (Date.now() / 20 + index * 10) % 360;
        const color = rainbowMode ? `hsl(${hue}, 100%, 50%)` : 
                     activePowerups.some(p => p.type === 'shield') ? '#00FF0088' : '#4CAF50';
        
        // Head shape
        if (head) {
            ctx.beginPath();
            ctx.arc(
                segment.x * CELL_SIZE + CELL_SIZE/2,
                segment.y * CELL_SIZE + CELL_SIZE/2,
                CELL_SIZE/2 - 2,
                0,
                Math.PI * 2
            );
            ctx.fillStyle = color;
            ctx.fill();
            
            // Eyes
            const eyeOffset = CELL_SIZE/4;
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(
                segment.x * CELL_SIZE + CELL_SIZE/2 + (direction === 'left' ? -eyeOffset : direction === 'right' ? eyeOffset : 0),
                segment.y * CELL_SIZE + CELL_SIZE/2 + (direction === 'up' ? -eyeOffset : direction === 'down' ? eyeOffset : 0),
                2, 0, Math.PI * 2
            );
            ctx.fill();
        }
        // Tail shape
        else if (tail) {
            ctx.beginPath();
            ctx.arc(
                segment.x * CELL_SIZE + CELL_SIZE/2,
                segment.y * CELL_SIZE + CELL_SIZE/2,
                CELL_SIZE/3,
                0,
                Math.PI * 2
            );
            ctx.fillStyle = color;
            ctx.fill();
        }
        // Body segments
        else {
            ctx.fillStyle = color;
            ctx.fillRect(
                segment.x * CELL_SIZE + 2,
                segment.y * CELL_SIZE + 2,
                CELL_SIZE - 4,
                CELL_SIZE - 4
            );
        }
    });
}

function updateStats() {
    document.getElementById('score').textContent = score;
    document.getElementById('length').textContent = snake.length;
    document.getElementById('highscore').textContent = highScore;
    
    const elapsed = Math.floor((Date.now() - startTime) / 1000);
    document.getElementById('time').textContent = 
        `${Math.floor(elapsed / 60)}:${String(elapsed % 60).padStart(2, '0')}`;
    
    document.getElementById('combo').textContent = `x${comboMultiplier}`;
    
    const powerupsList = activePowerups.map(p => `
        <div style="color: ${p.color}">
            ${p.type} (${Math.ceil((p.expiresAt - Date.now())/1000)}s)
        </div>
    `).join('');
    document.getElementById('powerups').innerHTML = powerupsList;
}

function gameStep() {
    if (paused) return;
    
    // Update active powerups
    activePowerups = activePowerups.filter(p => Date.now() < p.expiresAt);
    
    // Move snake
    direction = nextDirection;
    const head = {...snake[0]};
    
    switch(direction) {
        case 'up': head.y--; break;
        case 'down': head.y++; break;
        case 'left': head.x--; break;
        case 'right': head.x++; break;
    }
    
    // Check collisions
    const hasShield = activePowerups.some(p => p.type === 'shield');
    const wallCollision = head.x < 0 || head.x >= GRID_SIZE || head.y < 0 || head.y >= GRID_SIZE;
    const selfCollision = snake.some(s => s.x === head.x && s.y === head.y);
    
    if ((wallCollision || selfCollision) && !hasShield) {
        endGame();
        return;
    }
    
    if (wallCollision && hasShield) {
        head.x = (head.x + GRID_SIZE) % GRID_SIZE;
        head.y = (head.y + GRID_SIZE) % GRID_SIZE;
    }
    
    snake.unshift(head);
    
    // Check food collision
    let ateFood = false;
    food = food.filter(f => {
        if (head.x === f.x && head.y === f.y) {
            ateFood = true;
            createParticles(f.x, f.y, f.color);
            
            if (f.type === 'special') {
                score += 50 * comboMultiplier;
                SFX.specialEat();
                comboMultiplier++;
            } else if (f.type === 'powerup') {
                new Powerup().apply();
            } else {
                score += 10 * comboMultiplier;
                SFX.eat();
                comboMultiplier++;
            }
            
            if (comboTimeout) clearTimeout(comboTimeout);
            comboTimeout = setTimeout(() => comboMultiplier = 1, 5000);
            SFX.combo(comboMultiplier);
            
            return false;
        }
        return true;
    });
    
    if (!ateFood) {
        snake.pop();
    } else {
        generateFood();
    }
    
    // Update game speed based on length
    gameSpeed = Math.max(50, INITIAL_SPEED - Math.floor(snake.length / 3) * 10);
    clearInterval(gameLoop);
    gameLoop = setInterval(gameStep, gameSpeed);
    
    drawGame();
}

function drawGame() {
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw grid
    ctx.strokeStyle = '#ffffff10';
    for(let x = 0; x <= GRID_SIZE; x++) {
        ctx.beginPath();
        ctx.moveTo(x * CELL_SIZE, 0);
        ctx.lineTo(x * CELL_SIZE, canvas.height);
        ctx.stroke();
    }
    for(let y = 0; y <= GRID_SIZE; y++) {
        ctx.beginPath();
        ctx.moveTo(0, y * CELL_SIZE);
        ctx.lineTo(canvas.width, y * CELL_SIZE);
        ctx.stroke();
    }
    
    // Draw food
    food.forEach(f => {
        ctx.fillStyle = f.color;
        ctx.beginPath();
        ctx.arc(
            f.x * CELL_SIZE + CELL_SIZE/2,
            f.y * CELL_SIZE + CELL_SIZE/2,
            CELL_SIZE/2 - 2,
            0,
            Math.PI * 2
        );
        ctx.fill();
        
        // Food glow
        ctx.shadowColor = f.color;
        ctx.shadowBlur = 15;
        ctx.fill();
        ctx.shadowBlur = 0;
    });
    
    drawSnake();
    drawParticles();
    updateStats();
}

function endGame() {
    SFX.gameOver();
    clearInterval(gameLoop);
    gameOverElement.style.display = 'block';
    
    if (score > highScore) {
        highScore = score;
        localStorage.setItem('snakeHighScore', highScore);
    }
}

function resetGame() {
    snake = [{x: 10, y: 10}];
    direction = 'right';
    nextDirection = 'right';
    score = 0;
    gameSpeed = INITIAL_SPEED;
    startTime = Date.now();
    comboMultiplier = 1;
    activePowerups = [];
    food = [];
    particles = [];
    generateFood();
    
    clearInterval(gameLoop);
    gameLoop = setInterval(gameStep, gameSpeed);
    gameOverElement.style.display = 'none';
    paused = false;
    rainbowMode = false;
}

document.addEventListener('keydown', (e) => {
    switch(e.key) {
        case 'ArrowUp': if (direction !== 'down') nextDirection = 'up'; break;
        case 'ArrowDown': if (direction !== 'up') nextDirection = 'down'; break;
        case 'ArrowLeft': if (direction !== 'right') nextDirection = 'left'; break;
        case 'ArrowRight': if (direction !== 'left') nextDirection = 'right'; break;
        case ' ': paused = !paused; break;
        case 'Enter': resetGame(); break;
        case 'r': case 'R': rainbowMode = !rainbowMode; break;
        case 'm': case 'M': gainNode.gain.value = gainNode.gain.value > 0 ? 0 : 0.2; break;
    }
});

// Initialize game
resetGame();
</script>
</body>
</html>