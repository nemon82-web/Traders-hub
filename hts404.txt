//@version=6
indicator("HTS 404", overlay=true)

// Oryginalny kod HTS Multi
timeframe = input.timeframe(defval = "", title = "Timeframe", group = "General")
fast_ma = input.int(title="Fast MA", defval=33, minval = 1, group = "General")
slow_ma = input.int(title="Slow MA", defval=144, minval = 1, group = "General")
ma_method = input.string(title="MA Method", defval="RMA", options=["RMA", "EMA"], group = "General")

bar_color_positive = input.color(color.green, 'Up color', group = 'Colors')
bar_color_negative = input.color(color.red, 'Down color', group = 'Colors')

change_bar_color = input.bool(false, "Bar color")
cross = input.bool(true, "Show cross")
show_bands = input.bool(false, "Show stop loss bands")
show_wave_fill = input.bool(true, "Show waves fill")
smoothing = input.int(title="Waves smoothing", defval=20, minval = 1)

show_bg_color = input.bool(false, "Visible", group = "Background color")
smoothing_bg = input.int(title="Smoothing", defval=2, minval = 1, group = "Background color")

lower_timeframe = input.timeframe(defval = "", title = "Timeframe", group = "Lower timeframe fast MA")
show_lower_timeframe_fast_ma = input.bool(false, "Visible", group = "Lower timeframe fast MA") and not na(lower_timeframe)

tf = timeframe == '' ? timeframe.period : timeframe

if lower_timeframe == ''
    lower_timeframe := switch tf
        "3" => "1"
        "5" => "1"
        "15" => "5"
        "60" => "15"
        "240" => "60"
        "D" => "240"
        => na

calculate_ma(simple int length, simple string timeframe, simple string method) => 
    ma_high = request.security(syminfo.tickerid, timeframe, method == "RMA" ? ta.rma(high, length) : ta.ema(high, length), barmerge.gaps_off, barmerge.lookahead_off)
    ma_low = request.security(syminfo.tickerid, timeframe, method == "RMA" ? ta.rma(low, length) : ta.ema(low, length), barmerge.gaps_off, barmerge.lookahead_off)
    ma_close = request.security(syminfo.tickerid, timeframe, method == "RMA" ? ta.rma(close, length) : ta.ema(close, length), barmerge.gaps_off, barmerge.lookahead_off)
    ma_hl2 = request.security(syminfo.tickerid, timeframe, method == "RMA" ? ta.rma(hl2, length) : ta.ema(hl2, length), barmerge.gaps_off, barmerge.lookahead_off)
    ma_hl2_avg = math.sum(ma_hl2, smoothing) / smoothing

    color = ma_hl2 > ma_hl2_avg ? bar_color_positive : bar_color_negative

    [ma_high,  ma_low, ma_close, color, ma_hl2]

[fast_ma_high, fast_ma_low, fast_ma_close, fast_ma_color, fast_ma_hl2] = calculate_ma(fast_ma, timeframe, ma_method)
[slow_ma_high, slow_ma_low, slow_ma_close, slow_ma_color, slow_ma_hl2] = calculate_ma(slow_ma, timeframe, ma_method)
[lower_fast_ma_high, lower_fast_ma_low, lower_fast_ma_close, lower_fast_ma_color, lower_fast_ma_hl2] = calculate_ma(fast_ma, lower_timeframe, ma_method)

sl = ((fast_ma_hl2 - slow_ma_hl2) / 2) + slow_ma_hl2

distance = math.abs(fast_ma_close - slow_ma_close)
distance_smoothed = math.sum(distance, smoothing_bg) / smoothing_bg
increasing = distance > distance_smoothed
is_tranding = fast_ma_low > slow_ma_high or fast_ma_high < slow_ma_low
bgcolor(show_bg_color ? increasing ? fast_ma_low > slow_ma_high ? color.rgb(76, 175, 79, 80) : fast_ma_high < slow_ma_low ? color.rgb(255, 82, 82, 80) : na : na : na)

// Fast MA
fast_ma_high_plot = plot(fast_ma_high, title = "Fast High", color = color.new(fast_ma_color, 50), linewidth=1)
fast_ma_low_plot = plot(fast_ma_low, title = "Fast Low", color = color.new(fast_ma_color, 50), linewidth=1)
fill(fast_ma_high_plot, fast_ma_low_plot, color.new(fast_ma_color, show_wave_fill ? 86 : 100))
fast_ma_distance = fast_ma_high - fast_ma_low
plot(show_bands ? fast_ma_high + fast_ma_distance : na, title = "Fast High Max", color = color.new(fast_ma_color, 86), linewidth=1)
plot(show_bands ? fast_ma_low - fast_ma_distance : na, title = "Fast Low Max", color = color.new(fast_ma_color, 86), linewidth=1)

// Slow MA
slow_ma_high_plot = plot(slow_ma_high, title = "Slow High", color = color.new(slow_ma_color, 50), linewidth=1)
slow_ma_low_plot = plot(slow_ma_low, title = "Slow Low", color = color.new(slow_ma_color, 50), linewidth=1)
fill(slow_ma_high_plot, slow_ma_low_plot, color.new(slow_ma_color, show_wave_fill ? 86 : 100))
slow_ma_distance = slow_ma_high - slow_ma_low
plot(show_bands ? slow_ma_high + slow_ma_distance : na, title = "Slow High Max", color = color.new(slow_ma_color, 86), linewidth=1)
plot(show_bands ? slow_ma_low - slow_ma_distance : na, title = "Slow Low Max", color = color.new(slow_ma_color, 86), linewidth=1)

// Lower Timeframe Fast MA
lower_fast_ma_high_plot = plot(lower_fast_ma_high, title = "Lower Fast High", color = color.new(color.rgb(255, 230, 0), show_lower_timeframe_fast_ma ? 60 : 100), linewidth=1)
lower_fast_ma_low_plot = plot(lower_fast_ma_low, title = "Lower Fast Low", color = color.new(color.rgb(255, 230, 0), show_lower_timeframe_fast_ma ? 60 : 100), linewidth=1)
fill(lower_fast_ma_high_plot, lower_fast_ma_low_plot, color.new(color.white, show_lower_timeframe_fast_ma ? 86 : 100))

// Zadeklaruj zmienne globalne dla crossover i crossunder
var bool crossover_fast_slow_high = false
var bool crossover_fast_slow_low = false
var bool crossunder_fast_slow_high = false
var bool crossunder_fast_slow_low = false

// Przypisz wyniki crossover i crossunder do zmiennych globalnych
crossover_fast_slow_high := ta.crossover(fast_ma_high, slow_ma_high)
crossover_fast_slow_low := ta.crossover(fast_ma_low, slow_ma_high)
crossunder_fast_slow_high := ta.crossunder(fast_ma_high, slow_ma_low)
crossunder_fast_slow_low := ta.crossunder(fast_ma_low, slow_ma_low)

// Użyj zmiennych globalnych w wyrażeniach warunkowych
plot(cross and crossover_fast_slow_high ? slow_ma_high : na, color = color.white, linewidth = 5, style = plot.style_circles)
plot(cross and crossover_fast_slow_high ? slow_ma_high : na, color = bar_color_positive, linewidth = 4, style = plot.style_circles)
plot(cross and crossover_fast_slow_low ? slow_ma_high : na, color = color.white, linewidth = 5, style = plot.style_circles)
plot(cross and crossover_fast_slow_low ? slow_ma_high : na, color = bar_color_positive, linewidth = 4, style = plot.style_circles)
plot(cross and crossunder_fast_slow_high ? slow_ma_low : na, color = color.white, linewidth = 5, style = plot.style_circles)
plot(cross and crossunder_fast_slow_high ? slow_ma_low : na, color = bar_color_negative, linewidth = 4, style = plot.style_circles)
plot(cross and crossunder_fast_slow_low ? slow_ma_low : na, color = color.white, linewidth = 5, style = plot.style_circles)
plot(cross and crossunder_fast_slow_low ? slow_ma_low : na, color = bar_color_negative, linewidth = 4, style = plot.style_circles)

alertcondition(crossover_fast_slow_high, "Weak cross up")
alertcondition(crossover_fast_slow_low, "Strong cross up")
alertcondition(crossunder_fast_slow_high, "Weak cross down")
alertcondition(crossunder_fast_slow_low, "Strong cross down")

// ==========================================
// ===========   HTS BAR COLORS   ===========
// ==========================================

var bcolor = bar_color_positive
wave_offset = (fast_ma_high - fast_ma_low) / 3
signal = false

if close - wave_offset > fast_ma_high and bcolor != bar_color_positive
    bcolor := bar_color_positive
    signal := true
else if close + wave_offset < fast_ma_low and bcolor != bar_color_negative
    bcolor := bar_color_negative
    signal := true

barcolor(change_bar_color ? bcolor : na)

alertcondition(signal and bcolor == bar_color_positive, "Bar color changed to GREEN")
alertcondition(signal and bcolor == bar_color_negative, "Bar color changed to RED")

// ==========================================
// ===========     Kijun-Sen      ===========
// ==========================================
show_kijun = input.bool(true, title="Visible", group = "Kijun-Sen")
basePeriods = input.int(26, title="Period", group = "Kijun-Sen")
kijun_color = input.color(color.orange, 'Color', group = "Kijun-Sen")
donchian(len) => math.avg(ta.lowest(len), ta.highest(len))
baseLine = donchian(basePeriods)
plot(show_kijun ? baseLine : na, "Kijun-Sen line", kijun_color, 2)

// ==========================================
// ===========        ATR         ===========
// ==========================================
show_atr = input.bool(false, "Visible", group = "ATR")
atr_length = input.int(title="ATR length", defval=14, minval = 1, group = "ATR")
var table atrDisplay = table.new(position.bottom_center, 1, 1, bgcolor = color.black)
myAtr = ta.atr(atr_length)
if barstate.islast and show_atr
    table.cell(atrDisplay, 0, 0, str.tostring(myAtr, format.mintick), text_color = color.white, text_size = size.small)

// ==========================================
// ===========        EMA         ===========
// ==========================================

// Konfiguracja EMA 1
show_ema1 = input.bool(true, title="Show EMA 1", group="EMA 1")
ema1_length = input.int(50, title="EMA 1 Length", group="EMA 1")
ema1_color = input.color(color.yellow, title="EMA 1 Color", group="EMA 1")

// Konfiguracja EMA 2
show_ema2 = input.bool(true, title="Show EMA 2", group="EMA 2")
ema2_length = input.int(100, title="EMA 2 Length", group="EMA 2")
ema2_color = input.color(color.red, title="EMA 2 Color", group="EMA 2")

// Konfiguracja EMA 3
show_ema3 = input.bool(true, title="Show EMA 3", group="EMA 3")
ema3_length = input.int(200, title="EMA 3 Length", group="EMA 3")
ema3_color = input.color(color.green, title="EMA 3 Color", group="EMA 3")

// Obliczenia EMA
ema1 = ta.ema(close, ema1_length)
ema2 = ta.ema(close, ema2_length)
ema3 = ta.ema(close, ema3_length)

// Rysowanie EMA na wykresie
plot(show_ema1 ? ema1 : na, title="EMA 1", color=ema1_color, linewidth=2)
plot(show_ema2 ? ema2 : na, title="EMA 2", color=ema2_color, linewidth=2)
plot(show_ema3 ? ema3 : na, title="EMA 3", color=ema3_color, linewidth=2)

// ==========================================
// ===========     VIDYA + TMA    ===========
// ==========================================

// Konfiguracja VIDYA
show_vidya = input.bool(true, title="Show VIDYA", group="VIDYA")
vidya_length = input.int(22, title="VIDYA Periods", group="VIDYA")
vidya_src = input(close, title="VIDYA Source", group="VIDYA")
vidya_color = input.color(color.blue, title="VIDYA Color", group="VIDYA")

// Chande Momentum Oscillator dla VIDYA
getCMO(src, length) =>
    mom = ta.change(src)
    upSum = math.sum(math.max(mom, 0), length)
    downSum = math.sum(-math.min(mom, 0), length)
    out = (upSum - downSum) / (upSum + downSum)
    out

cmo = math.abs(getCMO(vidya_src, vidya_length))

// Obliczenie VIDYA na podstawie oryginalnego wskaźnika
ema = ta.ema(vidya_src, vidya_length)
alpha = 2 / ema + 1
var float vidya = na
vidya := vidya_src * alpha * cmo + nz(vidya[1]) * (1 - alpha * cmo)

// Rysowanie VIDYA na wykresie
plot(show_vidya ? vidya : na, title='VIDYA', linewidth=2, color=vidya_color)

// Konfiguracja TMA
show_tma = input.bool(true, title="Show TMA", group="TMA")
tma_length = input.int(33, title='TMA Periods', group="TMA")
tma_src = input(close, title="TMA Source", group="TMA")
tma_color = input.color(color.orange, title="TMA Color", group="TMA")

// Obliczenie TMA
trima = ta.sma(ta.sma(tma_src, tma_length), tma_length)

// Rysowanie TMA na wykresie
plot(show_tma ? trima : na, color=tma_color, linewidth=3, title="TMA")

// ==========================================
// ===========        PIVOTY      ===========
// ==========================================

AUTO = 'Auto'
DAILY = 'Daily'
WEEKLY = 'Weekly'
MONTHLY = 'Monthly'
QUARTERLY = 'Quarterly'
YEARLY = 'Yearly'
BIYEARLY = 'Biyearly'
TRIYEARLY = 'Triyearly'
QUINQUENNIALLY = 'Quinquennially'
DECENNIALLY = 'Decennially'

TRADITIONAL = 'Traditional'
FIBONACCI = 'Fibonacci'
WOODIE = 'Woodie'
CLASSIC = 'Classic'
DEMARK = 'DM'
CAMARILLA = 'Camarilla'

pivot_switch = input.bool(false, title='Pokaż Pivot Points:', group='Pivot Points - ustawienia')
kind = input.string('Traditional', title='Typ Pivot Points:', options=[TRADITIONAL, FIBONACCI, WOODIE, CLASSIC, DEMARK, CAMARILLA], group='Pivot Points - ustawienia')
look_back = input.int(1, title='Ilość Pivot Points w tył', minval=1, maxval=5000)
pivot_time_frame = input.string(DAILY, title='Interwał czasowy dla Pivot Points:', options=[AUTO, DAILY, WEEKLY, MONTHLY, QUARTERLY, YEARLY, BIYEARLY, TRIYEARLY, QUINQUENNIALLY, DECENNIALLY])
is_daily_based = input.bool(true, title='Użyj wartości dziennych dla Pivot Points:', tooltip='Gdy ta opcja jest odznaczona, punkty osiowe będą używały danych śróddziennych podczas obliczania na wykresach śróddziennych. Jeśli na wykresie wyświetlane są godziny rozszerzone, zostaną one uwzględnione podczas obliczania poziomów osiowych. Jeśli śróddzienne wartości OHLC różnią się od wartości dziennych (normalne w przypadku akcji), poziomy osiowe również będą się różnić.')
show_labels = input.bool(true, title='Pokaż oznaczenia Pivot Points:', group='Pivot Points - ustawienia')
show_prices = input.bool(true, title='Pokaż wartości Pivot Points:', group='Pivot Points - ustawienia')
position_labels = input.string('Prawa', 'Po której stronie oznaczenia dla Pivot Points:', options=['Lewa', 'Prawa'], group='Pivot Points - ustawienia')
line_width = input.int(1, title='Grubość lini Pivot Points:', minval=1, maxval=100, group='Pivot Points - ustawienia')

// Dodaj nowe włączniki dla pivotów tygodniowych i miesięcznych z możliwością zmiany koloru
show_weekly_pivot = input.bool(false, title="Pivot Tygodniowy", group="Pivot Points - ustawienia", inline="Weekly Pivot")
weekly_pivot_color = input.color(color.blue, "", group="Pivot Points - ustawienia", inline="Weekly Pivot")

show_monthly_pivot = input.bool(false, title="Pivot Miesięczny", group="Pivot Points - ustawienia", inline="Monthly Pivot")
monthly_pivot_color = input.color(color.red, "", group="Pivot Points - ustawienia", inline="Monthly Pivot")

// Zmienne dla pivotów tygodniowych i miesięcznych
var float weekly_pivot = na
var float monthly_pivot = na

// Zmienne do przechowywania linii i etykiet pivotów
var line weekly_pivot_line = na
var label weekly_pivot_label = na

var line monthly_pivot_line = na
var label monthly_pivot_label = na

// Funkcja do obliczania pivotu tygodniowego
calculate_weekly_pivot() =>
    weekly_high = request.security(syminfo.tickerid, "W", high[1], gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
    weekly_low = request.security(syminfo.tickerid, "W", low[1], gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
    weekly_close = request.security(syminfo.tickerid, "W", close[1], gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
    (weekly_high + weekly_low + weekly_close) / 3

// Funkcja do obliczania pivotu miesięcznego
calculate_monthly_pivot() =>
    monthly_high = request.security(syminfo.tickerid, "M", high[1], gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
    monthly_low = request.security(syminfo.tickerid, "M", low[1], gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
    monthly_close = request.security(syminfo.tickerid, "M", close[1], gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
    (monthly_high + monthly_low + monthly_close) / 3

// Oblicz pivoty tygodniowe i miesięczne
weekly_pivot := show_weekly_pivot ? calculate_weekly_pivot() : na
monthly_pivot := show_monthly_pivot ? calculate_monthly_pivot() : na

// ==========================================
// ====== RYSOWANIE PIVOTÓW NA WYKRESIE =====
// ==========================================

// Określ zakres słupków dla linii pivotów
lookback_bars = 20  // Liczba słupków wstecz
lookahead_bars = 20 // Liczba słupków do przodu

// Rysuj poziome linie i etykiety dla pivotów tygodniowych
if show_weekly_pivot and not na(weekly_pivot)
    if na(weekly_pivot_line)
        weekly_pivot_line := line.new(x1=bar_index - lookback_bars, y1=weekly_pivot, x2=bar_index + lookahead_bars, y2=weekly_pivot, color=weekly_pivot_color, width=line_width)
        weekly_pivot_label := label.new(x=bar_index + lookahead_bars, y=weekly_pivot, text="Weekly: " + str.tostring(weekly_pivot, format.mintick), color=weekly_pivot_color, textcolor=color.white, style=label.style_label_left, size=size.small)
    else
        line.set_xy1(weekly_pivot_line, x=bar_index - lookback_bars, y=weekly_pivot)
        line.set_xy2(weekly_pivot_line, x=bar_index + lookahead_bars, y=weekly_pivot)
        label.set_xy(weekly_pivot_label, x=bar_index + lookahead_bars, y=weekly_pivot)
        label.set_text(weekly_pivot_label, "Weekly: " + str.tostring(weekly_pivot, format.mintick))
else
    if not na(weekly_pivot_line)
        line.delete(weekly_pivot_line)
        label.delete(weekly_pivot_label)
        weekly_pivot_line := na
        weekly_pivot_label := na

// Rysuj poziome linie i etykiety dla pivotów miesięcznych
if show_monthly_pivot and not na(monthly_pivot)
    if na(monthly_pivot_line)
        monthly_pivot_line := line.new(x1=bar_index - lookback_bars, y1=monthly_pivot, x2=bar_index + lookahead_bars, y2=monthly_pivot, color=monthly_pivot_color, width=line_width)
        monthly_pivot_label := label.new(x=bar_index + lookahead_bars, y=monthly_pivot, text="Monthly: " + str.tostring(monthly_pivot, format.mintick), color=monthly_pivot_color, textcolor=color.white, style=label.style_label_left, size=size.small)
    else
        line.set_xy1(monthly_pivot_line, x=bar_index - lookback_bars, y=monthly_pivot)
        line.set_xy2(monthly_pivot_line, x=bar_index + lookahead_bars, y=monthly_pivot)
        label.set_xy(monthly_pivot_label, x=bar_index + lookahead_bars, y=monthly_pivot)
        label.set_text(monthly_pivot_label, "Monthly: " + str.tostring(monthly_pivot, format.mintick))
else
    if not na(monthly_pivot_line)
        line.delete(monthly_pivot_line)
        label.delete(monthly_pivot_label)
        monthly_pivot_line := na
        monthly_pivot_label := na


var DEF_COLOR = #808080
var DEF_COLOR_P = #b2b5be
var DEF_COLOR_S = #4caf50
var DEF_COLOR_R = #f05350
var arr_time = array.new_int()
var p = array.new_float()
p_color = input.color(DEF_COLOR_P, 'P‏  ‏  ‏', inline='P', group='Pivot Points - ustawienia')
p_show = input.bool(true, '', inline='P', group='Pivot Points - ustawienia')
var r1 = array.new_float()
var s1 = array.new_float()
s1_color = input.color(DEF_COLOR_S, 'S1', inline='S1/R1', group='Pivot Points - ustawienia')
s1_show = input.bool(true, '', inline='S1/R1', group='Pivot Points - ustawienia')
r1_color = input.color(DEF_COLOR_R, '‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏R1', inline='S1/R1', group='Pivot Points - ustawienia')
r1_show = input.bool(true, '', inline='S1/R1', group='Pivot Points - ustawienia')
var r2 = array.new_float()
var s2 = array.new_float()
s2_color = input.color(DEF_COLOR_S, 'S2', inline='S2/R2', group='Pivot Points - ustawienia')
s2_show = input.bool(true, '', inline='S2/R2', group='Pivot Points - ustawienia')
r2_color = input.color(DEF_COLOR_R, '‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏R2', inline='S2/R2', group='Pivot Points - ustawienia')
r2_show = input.bool(true, '', inline='S2/R2', group='Pivot Points - ustawienia')
var r3 = array.new_float()
var s3 = array.new_float()
s3_color = input.color(DEF_COLOR_S, 'S3', inline='S3/R3', group='Pivot Points - ustawienia')
s3_show = input.bool(true, '', inline='S3/R3', group='Pivot Points - ustawienia')
r3_color = input.color(DEF_COLOR_R, '‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏R3', inline='S3/R3', group='Pivot Points - ustawienia')
r3_show = input.bool(true, '', inline='S3/R3', group='Pivot Points - ustawienia')
var r4 = array.new_float()
var s4 = array.new_float()
s4_color = input.color(DEF_COLOR_S, 'S4', inline='S4/R4', group='Pivot Points - ustawienia')
s4_show = input.bool(false, '', inline='S4/R4', group='Pivot Points - ustawienia')
r4_color = input.color(DEF_COLOR_R, '‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏R4', inline='S4/R4', group='Pivot Points - ustawienia')
r4_show = input.bool(false, '', inline='S4/R4', group='Pivot Points - ustawienia')
var r5 = array.new_float()
var s5 = array.new_float()
s5_color = input.color(DEF_COLOR_S, 'S5', inline='S5/R5', group='Pivot Points - ustawienia')
s5_show = input.bool(false, '', inline='S5/R5', group='Pivot Points - ustawienia')
r5_color = input.color(DEF_COLOR_R, '‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏R5', inline='S5/R5', group='Pivot Points - ustawienia')
r5_show = input.bool(false, '', inline='S5/R5', group='Pivot Points - ustawienia')

pivotX_open = float(na)
pivotX_open := nz(pivotX_open[1], open)
pivotX_high = float(na)
pivotX_high := nz(pivotX_high[1], high)
pivotX_low = float(na)
pivotX_low := nz(pivotX_low[1], low)
pivotX_prev_open = float(na)
pivotX_prev_open := nz(pivotX_prev_open[1])
pivotX_prev_high = float(na)
pivotX_prev_high := nz(pivotX_prev_high[1])
pivotX_prev_low = float(na)
pivotX_prev_low := nz(pivotX_prev_low[1])
pivotX_prev_close = float(na)
pivotX_prev_close := nz(pivotX_prev_close[1])

get_pivot_resolution() =>
    resolution = 'M'
    if pivot_time_frame == AUTO
        if timeframe.isintraday
            resolution := timeframe.multiplier <= 15 ? 'D' : 'W'
        else if timeframe.isweekly or timeframe.ismonthly
            resolution := '12M'
    else if pivot_time_frame == DAILY
        resolution := 'D'
    else if pivot_time_frame == WEEKLY
        resolution := 'W'
    else if pivot_time_frame == MONTHLY
        resolution := 'M'
    else if pivot_time_frame == QUARTERLY
        resolution := '3M'
    else if pivot_time_frame == YEARLY or pivot_time_frame == BIYEARLY or pivot_time_frame == TRIYEARLY or pivot_time_frame == QUINQUENNIALLY or pivot_time_frame == DECENNIALLY
        resolution := '12M'
    resolution

var lines = array.new_line()
var labels = array.new_label()

draw_line(i, pivot, col) =>
    if array.size(arr_time) > 1
        array.push(lines, line.new(array.get(arr_time, i), array.get(pivot, i), array.get(arr_time, i + 1), array.get(pivot, i), color=col, xloc=xloc.bar_time, width=line_width))

draw_label(i, y, txt, txt_color) =>
    if (show_labels or show_prices) and not na(y)
        display_text = (show_labels ? txt : '') + (show_prices ? str.format(' ({0})', math.round_to_mintick(y)) : '')
        label_style = position_labels == 'Prawa' ? label.style_label_left : label.style_label_right
        x = position_labels == 'Lewa' ? array.get(arr_time, i) : array.get(arr_time, i + 1)
        array.push(labels, label.new(x=x, y=y, text=display_text, textcolor=txt_color, style=label_style, color=#00000000, xloc=xloc.bar_time))

traditional() =>
    pivotX_Median = (pivotX_prev_high + pivotX_prev_low + pivotX_prev_close) / 3
    array.push(p, pivotX_Median)
    array.push(r1, pivotX_Median * 2 - pivotX_prev_low)
    array.push(s1, pivotX_Median * 2 - pivotX_prev_high)
    array.push(r2, pivotX_Median + 1 * (pivotX_prev_high - pivotX_prev_low))
    array.push(s2, pivotX_Median - 1 * (pivotX_prev_high - pivotX_prev_low))
    array.push(r3, pivotX_Median * 2 + pivotX_prev_high - 2 * pivotX_prev_low)
    array.push(s3, pivotX_Median * 2 - (2 * pivotX_prev_high - pivotX_prev_low))
    array.push(r4, pivotX_Median * 3 + pivotX_prev_high - 3 * pivotX_prev_low)
    array.push(s4, pivotX_Median * 3 - (3 * pivotX_prev_high - pivotX_prev_low))
    array.push(r5, pivotX_Median * 4 + pivotX_prev_high - 4 * pivotX_prev_low)
    array.push(s5, pivotX_Median * 4 - (4 * pivotX_prev_high - pivotX_prev_low))

fibonacci() =>
    pivotX_Median = (pivotX_prev_high + pivotX_prev_low + pivotX_prev_close) / 3
    pivot_range = pivotX_prev_high - pivotX_prev_low
    array.push(p, pivotX_Median)
    array.push(r1, pivotX_Median + 0.382 * pivot_range)
    array.push(s1, pivotX_Median - 0.382 * pivot_range)
    array.push(r2, pivotX_Median + 0.618 * pivot_range)
    array.push(s2, pivotX_Median - 0.618 * pivot_range)
    array.push(r3, pivotX_Median + 1 * pivot_range)
    array.push(s3, pivotX_Median - 1 * pivot_range)

woodie() =>
    pivotX_Woodie_Median = (pivotX_prev_high + pivotX_prev_low + pivotX_open * 2) / 4
    pivot_range = pivotX_prev_high - pivotX_prev_low
    array.push(p, pivotX_Woodie_Median)
    array.push(r1, pivotX_Woodie_Median * 2 - pivotX_prev_low)
    array.push(s1, pivotX_Woodie_Median * 2 - pivotX_prev_high)
    array.push(r2, pivotX_Woodie_Median + 1 * pivot_range)
    array.push(s2, pivotX_Woodie_Median - 1 * pivot_range)
    pivot_point_r3 = pivotX_prev_high + 2 * (pivotX_Woodie_Median - pivotX_prev_low)
    pivot_point_s3 = pivotX_prev_low - 2 * (pivotX_prev_high - pivotX_Woodie_Median)
    array.push(r3, pivot_point_r3)
    array.push(s3, pivot_point_s3)
    array.push(r4, pivot_point_r3 + pivot_range)
    array.push(s4, pivot_point_s3 - pivot_range)

classic() =>
    pivotX_Median = (pivotX_prev_high + pivotX_prev_low + pivotX_prev_close) / 3
    pivot_range = pivotX_prev_high - pivotX_prev_low
    array.push(p, pivotX_Median)
    array.push(r1, pivotX_Median * 2 - pivotX_prev_low)
    array.push(s1, pivotX_Median * 2 - pivotX_prev_high)
    array.push(r2, pivotX_Median + 1 * pivot_range)
    array.push(s2, pivotX_Median - 1 * pivot_range)
    array.push(r3, pivotX_Median + 2 * pivot_range)
    array.push(s3, pivotX_Median - 2 * pivot_range)
    array.push(r4, pivotX_Median + 3 * pivot_range)
    array.push(s4, pivotX_Median - 3 * pivot_range)

demark() =>
    pivotX_Demark_X = pivotX_prev_high + pivotX_prev_low * 2 + pivotX_prev_close
    if pivotX_prev_close == pivotX_prev_open
        pivotX_Demark_X := pivotX_prev_high + pivotX_prev_low + pivotX_prev_close * 2
    if pivotX_prev_close > pivotX_prev_open
        pivotX_Demark_X := pivotX_prev_high * 2 + pivotX_prev_low + pivotX_prev_close
    array.push(p, pivotX_Demark_X / 4)
    array.push(r1, pivotX_Demark_X / 2 - pivotX_prev_low)
    array.push(s1, pivotX_Demark_X / 2 - pivotX_prev_high)

camarilla() =>
    pivotX_Median = (pivotX_prev_high + pivotX_prev_low + pivotX_prev_close) / 3
    pivot_range = pivotX_prev_high - pivotX_prev_low
    array.push(p, pivotX_Median)
    array.push(r1, pivotX_prev_close + pivot_range * 1.1 / 12.0)
    array.push(s1, pivotX_prev_close - pivot_range * 1.1 / 12.0)
    array.push(r2, pivotX_prev_close + pivot_range * 1.1 / 6.0)
    array.push(s2, pivotX_prev_close - pivot_range * 1.1 / 6.0)
    array.push(r3, pivotX_prev_close + pivot_range * 1.1 / 4.0)
    array.push(s3, pivotX_prev_close - pivot_range * 1.1 / 4.0)
    array.push(r4, pivotX_prev_close + pivot_range * 1.1 / 2.0)
    array.push(s4, pivotX_prev_close - pivot_range * 1.1 / 2.0)
    r5_val = pivotX_prev_high / pivotX_prev_low * pivotX_prev_close
    array.push(r5, r5_val)
    array.push(s5, 2 * pivotX_prev_close - r5_val)

calc_pivot() =>
    if kind == TRADITIONAL
        traditional()
    else if kind == FIBONACCI
        fibonacci()
    else if kind == WOODIE
        woodie()
    else if kind == CLASSIC
        classic()
    else if kind == DEMARK
        demark()
    else if kind == CAMARILLA
        camarilla()

resolution = get_pivot_resolution()

SIMPLE_DIVISOR = -1
custom_years_divisor = switch pivot_time_frame
    BIYEARLY => 2
    TRIYEARLY => 3
    QUINQUENNIALLY => 5
    DECENNIALLY => 10
    => SIMPLE_DIVISOR

calc_high(prev, curr) =>
    if na(prev) or na(curr)
        nz(prev, nz(curr, na))
    else
        math.max(prev, curr)

calc_low(prev, curr) =>
    if not na(prev) and not na(curr)
        math.min(prev, curr)
    else
        nz(prev, nz(curr, na))

calc_OHLC_for_pivot(custom_years_divisor) =>
    if custom_years_divisor == SIMPLE_DIVISOR
        [open, high, low, close, open[1], high[1], low[1], close[1], time[1], time_close]
    else
        var prev_sec_open = float(na)
        var prev_sec_high = float(na)
        var prev_sec_low = float(na)
        var prev_sec_close = float(na)
        var prev_sec_time = int(na)
        var curr_sec_open = float(na)
        var curr_sec_high = float(na)
        var curr_sec_low = float(na)
        var curr_sec_close = float(na)
        if year(time_close) % custom_years_divisor == 0
            curr_sec_open := open
            curr_sec_high := high
            curr_sec_low := low
            curr_sec_close := close
            prev_sec_high := high[1]
            prev_sec_low := low[1]
            prev_sec_close := close[1]
            prev_sec_time := time[1]
            for i = 2 to custom_years_divisor by 1
                prev_sec_open := nz(open[i], prev_sec_open)
                prev_sec_high := calc_high(prev_sec_high, high[i])
                prev_sec_low := calc_low(prev_sec_low, low[i])
                prev_sec_time := nz(time[i], prev_sec_time)
        [curr_sec_open, curr_sec_high, curr_sec_low, curr_sec_close, prev_sec_open, prev_sec_high, prev_sec_low, prev_sec_close, prev_sec_time, time_close]

[sec_open, sec_high, sec_low, sec_close, prev_sec_open, prev_sec_high, prev_sec_low, prev_sec_close, prev_sec_time, sec_time] = request.security(syminfo.tickerid, resolution, calc_OHLC_for_pivot(custom_years_divisor), lookahead=barmerge.lookahead_on)
sec_open_gaps_on = request.security(syminfo.tickerid, resolution, open, gaps=barmerge.gaps_on, lookahead=barmerge.lookahead_on)

// Global variables for ta.change() results
time_change = ta.change(time(resolution)) != 0
sec_open_change = ta.change(sec_open) != 0

is_change_years = custom_years_divisor > 0 and time_change and year(time_close) % custom_years_divisor == 0

var is_change = false
var uses_current_bar = timeframe.isintraday and kind == WOODIE
var change_time = int(na)
is_time_change = time_change and custom_years_divisor == SIMPLE_DIVISOR or is_change_years
if is_time_change
    change_time := time

var start_time = time
var was_last_premarket = false
var start_calculate_in_premarket = false

is_last_premarket = barstate.islast and session.ispremarket and time_close > sec_time and not was_last_premarket

if is_last_premarket
    was_last_premarket := true
    start_calculate_in_premarket := true
if session.ismarket
    was_last_premarket := false

without_time_change = barstate.islast and array.size(arr_time) == 0
is_can_calc_pivot = not uses_current_bar and is_time_change and session.ismarket or sec_open_change and not start_calculate_in_premarket or is_last_premarket or uses_current_bar and not na(sec_open_gaps_on) or without_time_change
enough_bars_for_calculate = prev_sec_time >= start_time or is_daily_based

if is_can_calc_pivot and enough_bars_for_calculate
    if array.size(arr_time) == 0 and is_daily_based
        pivotX_prev_open := prev_sec_open[1]
        pivotX_prev_high := prev_sec_high[1]
        pivotX_prev_low := prev_sec_low[1]
        pivotX_prev_close := prev_sec_close[1]
        pivotX_open := sec_open[1]
        pivotX_high := sec_high[1]
        pivotX_low := sec_low[1]
        array.push(arr_time, start_time)
        calc_pivot()

    if is_daily_based
        if is_last_premarket
            pivotX_prev_open := sec_open
            pivotX_prev_high := sec_high
            pivotX_prev_low := sec_low
            pivotX_prev_close := sec_close
            pivotX_open := open
            pivotX_high := high
            pivotX_low := low
        else
            pivotX_prev_open := prev_sec_open
            pivotX_prev_high := prev_sec_high
            pivotX_prev_low := prev_sec_low
            pivotX_prev_close := prev_sec_close
            pivotX_open := sec_open
            pivotX_high := sec_high
            pivotX_low := sec_low
    else
        pivotX_prev_high := pivotX_high
        pivotX_prev_low := pivotX_low
        pivotX_prev_open := pivotX_open
        pivotX_prev_close := close[1]
        pivotX_open := open
        pivotX_high := high
        pivotX_low := low

    if barstate.islast and not is_change and array.size(arr_time) > 0 and not without_time_change
        array.set(arr_time, array.size(arr_time) - 1, change_time)
    else if without_time_change
        array.push(arr_time, start_time)
    else
        array.push(arr_time, nz(change_time, time))

    calc_pivot()

    if array.size(arr_time) > look_back
        if array.size(arr_time) > 0
            array.shift(arr_time)
        if array.size(p) > 0 and p_show and pivot_switch
            array.shift(p)
        if array.size(r1) > 0 and r1_show and pivot_switch
            array.shift(r1)
        if array.size(s1) > 0 and s1_show and pivot_switch
            array.shift(s1)
        if array.size(r2) > 0 and r2_show and pivot_switch
            array.shift(r2)
        if array.size(s2) > 0 and s2_show and pivot_switch
            array.shift(s2)
        if array.size(r3) > 0 and r3_show and pivot_switch
            array.shift(r3)
        if array.size(s3) > 0 and s3_show and pivot_switch
            array.shift(s3)
        if array.size(r4) > 0 and r4_show and pivot_switch
            array.shift(r4)
        if array.size(s4) > 0 and s4_show and pivot_switch
            array.shift(s4)
        if array.size(r5) > 0 and r5_show and pivot_switch
            array.shift(r5)
        if array.size(s5) > 0 and s5_show and pivot_switch
            array.shift(s5)
    is_change := true
else if not is_daily_based
    pivotX_high := math.max(pivotX_high, high)
    pivotX_low := math.min(pivotX_low, low)

if barstate.islast and not is_daily_based and array.size(arr_time) == 0
    runtime.error('Not enough intraday data to calculate Pivot Points. Lower the Ustawienia dla Pivot Points Timeframe or turn on the \'Use Daily-based Values\' option in the indicator settings.')

if barstate.islast and array.size(arr_time) > 0 and is_change
    is_change := false
    if custom_years_divisor > 0
        last_pivot_time = array.get(arr_time, array.size(arr_time) - 1)
        pivot_timeframe = str.tostring(12 * custom_years_divisor) + 'M'
        estimate_pivot_time = last_pivot_time + timeframe.in_seconds(pivot_timeframe) * 1000
        array.push(arr_time, estimate_pivot_time)
    else
        array.push(arr_time, time_close(resolution))

    for i = 0 to array.size(lines) - 1 by 1
        if array.size(lines) > 0
            line.delete(array.shift(lines))
        if array.size(labels) > 0
            label.delete(array.shift(labels))

    for i = 0 to array.size(arr_time) - 2 by 1
        if array.size(p) > 0 and p_show and pivot_switch
            draw_line(i, p, p_color)
            draw_label(i, array.get(p, i), 'P', p_color)
        if array.size(r1) > 0 and r1_show and pivot_switch
            draw_line(i, r1, r1_color)
            draw_label(i, array.get(r1, i), 'R1', r1_color)
        if array.size(s1) > 0 and s1_show and pivot_switch
            draw_line(i, s1, s1_color)
            draw_label(i, array.get(s1, i), 'S1', s1_color)
        if array.size(r2) > 0 and r2_show and pivot_switch
            draw_line(i, r2, r2_color)
            draw_label(i, array.get(r2, i), 'R2', r2_color)
        if array.size(s2) > 0 and s2_show and pivot_switch
            draw_line(i, s2, s2_color)
            draw_label(i, array.get(s2, i), 'S2', s2_color)
        if array.size(r3) > 0 and r3_show and pivot_switch
            draw_line(i, r3, r3_color)
            draw_label(i, array.get(r3, i), 'R3', r3_color)
        if array.size(s3) > 0 and s3_show and pivot_switch
            draw_line(i, s3, s3_color)
            draw_label(i, array.get(s3, i), 'S3', s3_color)
        if array.size(r4) > 0 and r4_show and pivot_switch
            draw_line(i, r4, r4_color)
            draw_label(i, array.get(r4, i), 'R4', r4_color)
        if array.size(s4) > 0 and s4_show and pivot_switch
            draw_line(i, s4, s4_color)
            draw_label(i, array.get(s4, i), 'S4', s4_color)
        if array.size(r5) > 0 and r5_show and pivot_switch
            draw_line(i, r5, r5_color)
            draw_label(i, array.get(r5, i), 'R5', r5_color)
        if array.size(s5) > 0 and s5_show and pivot_switch
            draw_line(i, s5, s5_color)
            draw_label(i, array.get(s5, i), 'S5', s5_color)


// WARUNKI ALERTÓW
isUptrendAlert = ta.crossover(fast_ma_low, slow_ma_high)  // Zamiast HTSFastLow i HTSSlowHigh
isDowntrendAlert = ta.crossunder(fast_ma_high, slow_ma_low)  // Zamiast HTSFastHigh i HTSSlowLow
alertcondition(isUptrendAlert, 'Trend wzrostowy', 'Szybsza przecina wolniejszą w kierunku wzrostowym')
alertcondition(isDowntrendAlert, 'Trend spadkowy', 'Szybsza przecina wolniejszą w kierunku spadkowym')

// Pozycja tabeli
tableLocation = input.string('Prawy dolny róg', title='Położenie tabeli z Trendem:', options=['Lewy górny róg', 'Lewa strona środek', 'Lewy dolny róg', 'Środek góra', 'Środek', 'Środek dół', 'Prawy górny róg', 'Prawa strona środek', 'Prawy dolny róg'], group='HTS Tabela - ustawienia')
neutralSymbol = input.string("●", title="Symbol neutralny:", options=["●", "⏺", "▪", "■"], group='HTS Tabela - ustawienia')
show_rsi_row = input.bool(false, title="Wyświetl wiersz RSI w Tabeli:", group='HTS Tabela - ustawienia')
rsiLength = input.int(14, title='Długość RSI:', group='HTS Tabela - ustawienia')

// Deklaracja zmiennej tabeli
var table trendTable = na

// Zmienna globalna dla pozycji tabeli
var tablePos = position.top_right
switch tableLocation
    'Lewy górny róg' => tablePos := position.top_left
    'Lewa strona środek' => tablePos := position.middle_left
    'Lewy dolny róg' => tablePos := position.bottom_left
    'Środek góra' => tablePos := position.top_center
    'Środek' => tablePos := position.middle_center
    'Środek dół' => tablePos := position.bottom_center
    'Prawy górny róg' => tablePos := position.top_right
    'Prawa strona środek' => tablePos := position.middle_right
    'Prawy dolny róg' => tablePos := position.bottom_right

// Aktualizacja tabeli w nowej pozycji
if barstate.isfirst
    if na(trendTable)
        trendTable := table.new(tablePos, 5, 5, border_width=3)
    else
        table.delete(trendTable)
        trendTable := table.new(tablePos, 5, 5, border_width=3)

// Kolory dla trendów
upColor = #26a69a
downColor = #f05350
neutralColor = #fbff00

// Funkcja pobierająca trend z różnych interwałów
f_getTrend() =>
    HTSFastHigh_local = fast_ma_high  // Zamiast ta.rma(high, lenFast)
    HTSFastLow_local = fast_ma_low  // Zamiast ta.rma(low, lenFast)
    HTSSlowHigh_local = slow_ma_high  // Zamiast ta.rma(high, lenSlow)
    HTSSlowLow_local = slow_ma_low  // Zamiast ta.rma(low, lenSlow)
    isUptrend_local = HTSFastLow_local > HTSSlowHigh_local
    isDowntrend_local = HTSFastHigh_local < HTSSlowLow_local
    [isUptrend_local, isDowntrend_local]

// Funkcja wypełniająca komórki tabeli
f_fillCell(_column, _row, _cellText, _c_color, _text_color) =>
    if not na(trendTable)  // Dodaj sprawdzenie, czy trendTable istnieje
        table.cell(trendTable, _column, _row, _cellText, bgcolor=color.new(_c_color, 90), text_color=_text_color, height=3, width=4)

// Funkcje sprawdzające pozycję ceny względem wstęg dla różnych interwałów
f_getPriceBandPosition() =>
    priceAboveFast = close > fast_ma_high  // Zamiast HTSFastHigh
    priceInsideFast = close < fast_ma_high and close > fast_ma_low  // Zamiast HTSFastLow
    priceBelowFast = close < fast_ma_low  // Zamiast HTSFastLow

    priceAboveSlow = close > slow_ma_high  // Zamiast HTSSlowHigh
    priceInsideSlow = close < slow_ma_high and close > slow_ma_low  // Zamiast HTSSlowLow
    priceBelowSlow = close < slow_ma_low  // Zamiast HTSSlowLow

    [priceAboveFast, priceInsideFast, priceBelowFast, priceAboveSlow, priceInsideSlow, priceBelowSlow]

// Funkcja określająca kolor komórki RSI
f_rsiColor(rsi) =>
    rsi > 70 ? downColor : rsi < 30 ? color.rgb(0, 230, 118) : upColor

// Funkcja do konwersji interwału na przyjazną nazwę
f_intervalToLabel(interval) =>
    if interval == '1'
        'm1'
    else if interval == '3'
        'm3'
    else if interval == '5'
        'm5'
    else if interval == '15'
        'm15'
    else if interval == '30'
        'm30'
    else if interval == '45'
        'm45'
    else if interval == '60'
        'H1'
    else if interval == '120'
        'H2'
    else if interval == '180'
        'H3'
    else if interval == '240'
        'H4'
    else if interval == 'D'
        'D1'
    else if interval == 'W'
        'W1'
    else if interval == 'M'
        'M1'
    else
        interval  // Domyślnie zwróć wartość wejściową, jeśli nie pasuje do żadnego przypadku

// Dodaj nowe zmienne wejściowe dla interwałów
firstInterval = input.timeframe('1', title="Pierwszy interwał dla Trendu:", group="HTS Tabela - Interwały - ustawienia")
secondInterval = input.timeframe('5', title="Drugi interwał dla Trendu:", group="HTS Tabela - Interwały - ustawienia")
thirdInterval = input.timeframe('60', title="Trzeci interwał dla Trendu:", group="HTS Tabela - Interwały - ustawienia")
fourthInterval = input.timeframe('D', title="Czwarty interwał dla Trendu:", group="HTS Tabela - Interwały - ustawienia")

// Pobieranie trendów z różnych interwałów czasowych (używając wybranych interwałów)
[up_01, down_01] = request.security(syminfo.tickerid, firstInterval, f_getTrend())
[up_02, down_02] = request.security(syminfo.tickerid, secondInterval, f_getTrend())
[up_03, down_03] = request.security(syminfo.tickerid, thirdInterval, f_getTrend())
[up_04, down_04] = request.security(syminfo.tickerid, fourthInterval, f_getTrend())

// Generowanie symboli strzałów dla różnych interwałów
glyph1 = up_01 ? '▲ ' : down_01 ? '▼ ' : neutralSymbol + ' '
glyph2 = up_02 ? '▲ ' : down_02 ? '▼ ' : neutralSymbol + ' '
glyph3 = up_03 ? '▲ ' : down_03 ? '▼ ' : neutralSymbol + ' '
glyph4 = up_04 ? '▲ ' : down_04 ? '▼ ' : neutralSymbol + ' '

// Pobieranie pozycji ceny dla różnych interwałów
[aboveF_01, insideF_01, belowF_01, aboveS_01, insideS_01, belowS_01] = request.security(syminfo.tickerid, firstInterval, f_getPriceBandPosition())
[aboveF_02, insideF_02, belowF_02, aboveS_02, insideS_02, belowS_02] = request.security(syminfo.tickerid, secondInterval, f_getPriceBandPosition())
[aboveF_03, insideF_03, belowF_03, aboveS_03, insideS_03, belowS_03] = request.security(syminfo.tickerid, thirdInterval, f_getPriceBandPosition())
[aboveF_04, insideF_04, belowF_04, aboveS_04, insideS_04, belowS_04] = request.security(syminfo.tickerid, fourthInterval, f_getPriceBandPosition())

// Pobieranie wartości RSI dla różnych interwałów
rsi_01 = request.security(syminfo.tickerid, firstInterval, ta.rsi(close, rsiLength))
rsi_02 = request.security(syminfo.tickerid, secondInterval, ta.rsi(close, rsiLength))
rsi_03 = request.security(syminfo.tickerid, thirdInterval, ta.rsi(close, rsiLength))
rsi_04 = request.security(syminfo.tickerid, fourthInterval, ta.rsi(close, rsiLength))

// W sekcji if barstate.islast dodaj po pierwszym wierszu:
if barstate.islast
    // Pierwszy wiersz - trend (pozostaw bez zmian)
    f_fillCell(1, 0, glyph1 + f_intervalToLabel(firstInterval), up_01 ? upColor : down_01 ? downColor : neutralColor, up_01 ? upColor : down_01 ? downColor : neutralColor)
    f_fillCell(2, 0, glyph2 + f_intervalToLabel(secondInterval), up_02 ? upColor : down_02 ? downColor : neutralColor, up_02 ? upColor : down_02 ? downColor : neutralColor)
    f_fillCell(3, 0, glyph3 + f_intervalToLabel(thirdInterval), up_03 ? upColor : down_03 ? downColor : neutralColor, up_03 ? upColor : down_03 ? downColor : neutralColor)
    f_fillCell(4, 0, glyph4 + f_intervalToLabel(fourthInterval), up_04 ? upColor : down_04 ? downColor : neutralColor, up_04 ? upColor : down_04 ? downColor : neutralColor)

    // Drugi wiersz - pozycja względem szybkiej wstęgi
    f_fillCell(1, 1, aboveF_01 ? '▲' : insideF_01 ? neutralSymbol : '▼', aboveF_01 ? upColor : insideF_01 ? neutralColor : downColor, aboveF_01 ? upColor : insideF_01 ? neutralColor : downColor)
    f_fillCell(2, 1, aboveF_02 ? '▲' : insideF_02 ? neutralSymbol : '▼', aboveF_02 ? upColor : insideF_02 ? neutralColor : downColor, aboveF_02 ? upColor : insideF_02 ? neutralColor : downColor)
    f_fillCell(3, 1, aboveF_03 ? '▲' : insideF_03 ? neutralSymbol : '▼', aboveF_03 ? upColor : insideF_03 ? neutralColor : downColor, aboveF_03 ? upColor : insideF_03 ? neutralColor : downColor)
    f_fillCell(4, 1, aboveF_04 ? '▲' : insideF_04 ? neutralSymbol : '▼', aboveF_04 ? upColor : insideF_04 ? neutralColor : downColor, aboveF_04 ? upColor : insideF_04 ? neutralColor : downColor)

    // Trzeci wiersz - pozycja względem wolnej wstęgi
    f_fillCell(1, 2, aboveS_01 ? '▲' : insideS_01 ? neutralSymbol : '▼', aboveS_01 ? upColor : insideS_01 ? neutralColor : downColor, aboveS_01 ? upColor : insideS_01 ? neutralColor : downColor)
    f_fillCell(2, 2, aboveS_02 ? '▲' : insideS_02 ? neutralSymbol : '▼', aboveS_02 ? upColor : insideS_02 ? neutralColor : downColor, aboveS_02 ? upColor : insideS_02 ? neutralColor : downColor)
    f_fillCell(3, 2, aboveS_03 ? '▲' : insideS_03 ? neutralSymbol : '▼', aboveS_03 ? upColor : insideS_03 ? neutralColor : downColor, aboveS_03 ? upColor : insideS_03 ? neutralColor : downColor)
    f_fillCell(4, 2, aboveS_04 ? '▲' : insideS_04 ? neutralSymbol : '▼', aboveS_04 ? upColor : insideS_04 ? neutralColor : downColor, aboveS_04 ? upColor : insideS_04 ? neutralColor : downColor)

    // Czwarty wiersz - wartości RSI (tylko jeśli show_rsi_row jest włączone)
    if show_rsi_row
        f_fillCell(1, 3, str.tostring(rsi_01, '#.0'), f_rsiColor(rsi_01), f_rsiColor(rsi_01))
        f_fillCell(2, 3, str.tostring(rsi_02, '#.0'), f_rsiColor(rsi_02), f_rsiColor(rsi_02))
        f_fillCell(3, 3, str.tostring(rsi_03, '#.0'), f_rsiColor(rsi_03), f_rsiColor(rsi_03))
        f_fillCell(4, 3, str.tostring(rsi_04, '#.0'), f_rsiColor(rsi_04), f_rsiColor(rsi_04))

    // Dodanie piątej kolumny z etykietami  
    f_fillCell(0, 0, 'Trend:', #808080, #808080)
    f_fillCell(0, 1, str.tostring(fast_ma), #808080, fast_ma_color)  // Zamiast lenFast i HTSFastColor
    f_fillCell(0, 2, str.tostring(slow_ma), #808080, slow_ma_color)  // Zamiast lenSlow i HTSSlowColor
    if show_rsi_row
        f_fillCell(0, 3, 'RSI:', #808080, #808080)